# [Dubbo面试踩坑](https://www.cnblogs.com/lxyit/p/9035094.html)

#### 1.Dubbo支持哪些协议，每种协议的应用场景，优缺点？

- **dubbo：** 单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化；
- **rmi：** 采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。 多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞；
- **webservice：** 基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用；
- **http：** 基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用；
- **hessian：** 集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；
- **memcache：** 基于memcached实现的RPC协议
- **redis：** 基于redis实现的RPC协议

#### 2.Dubbo超时时间怎样设置？

　Dubbo超时时间设置有两种方式：

- 服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。
- 服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。

#### 3.Dubbo有些哪些注册中心？

- **Multicast注册中心：** Multicast注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；
- **Zookeeper注册中心：** 基于分布式协调系统Zookeeper实现，采用Zookeeper的watch机制实现数据变更；
- **redis注册中心：** 基于redis实现，采用key/Map存储，住key存储服务名和类型，Map中key存储服务URL，value服务过期时间。基于redis的发布/订阅模式通知数据变更；
- **Simple注册中心**

#### 4.Dubbo集群的负载均衡有哪些策略　　

　Dubbo提供了常见的集群策略实现，并预扩展点予以自行实现。

- **Random LoadBalance:** 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；
- **RoundRobin LoadBalance:** 轮循选取提供者策略，平均分布，但是存在请求累积的问题；
- **LeastActive LoadBalance:** 最少活跃调用策略，解决慢提供者接收更少的请求；
- **ConstantHash LoadBalance:** 一致性Hash策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；

 **zookeeper是如何保证事务的顺序一致性的** 
zookeeper采用了递增的事务Id来标识，所有的proposal都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行 





1.同时配置了XML和properties文件，则properties中的配置无效

只有XML没有配置时，properties才生效。

 

2.dubbo缺省会在启动时检查依赖是否可用，不可用就抛出异常，阻止spring初始化完成，check属性默认为true。测试时有些服务不关心或者出现了循环依赖，将check设置为false

 

3.为了方便开发测试，线下有一个所有服务可用的注册中心，这时，如果有一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。解决：让服务提供者开发方，只订阅服务，而不注册正在开发的服务，通过直连测试正在开发的服务。设置dubbo:registry标签的register属性为false。

 

4.spring 2.x初始化死锁问题。在spring解析到dubbo:service时，就已经向外暴露了服务，而spring还在接着初始化其他bean，如果这时有请求进来，并且服务的实现类里有调用applicationContext.getBean()的用法。getBean线程和spring初始化线程的锁的顺序不一样，导致了线程死锁，不能提供服务，启动不了。

解决：不要在服务的实现类中使用applicationContext.getBean();如果不想依赖配置顺序，可以将dubbo:provider的deplay属性设置为-1，使dubbo在容器初始化完成后再暴露服务。

 

5.服务注册不上

检查dubbo的jar包有没有在classpath中，以及有没有重复的jar包

检查暴露服务的spring配置有没有加载

在服务提供者机器上测试与注册中心的网络是否通

 

6.出现RpcException: No provider available for remote service异常怎么办？

表示没有可用的服务提供者，

1). 检查连接的注册中心是否正确

2). 到注册中心查看相应的服务提供者是否存在

3). 检查服务提供者是否正常运行

 

7.出现"消息发送失败"异常怎么办？

通常是接口方法的传入传出参数未实现Serializable接口。

 

8.SpringCloud和Dubbo的比较

相同点：都能提供服务注册，调用，监控

spring cloud提供了一整套企业级分布式云应用的完美解决方案，能够结合spring boot,docker实现快速开发的目的,核心要素在于服务的发现，注册，路由，熔断降级，分布式配置，dubbo只有spring cloud的一部分rpc的功能服务治理

spring cloud的服务调用方式是rest api,可以跨平台，dubbo的服务调用方式是RPC,默认不能跨平台，需要实现一层代理，以rest方式提供对外服务。

spring cloud的常用服务注册中心是zookeeper，spring cloud常用服务注册中心是spring cloud netflix eureka

spring cloud的服务监控是spring boot admin, dubbo的服务监控是dubbo-monitor

 

 

 

9.为什么选择dubbo

提供了远程通讯，对多种基于单一长连接的NIO框架抽象封装，适用于小数据量，大并发的服务调用，如果数据量较大，可以使用多个连接。

提供了负载均衡和容错机制

服务自动注册与发现

与spring集成配置简单

支持多种协议，默认TCP协议

10.为什么消者比提供者个数多？

dubbo采用单一长连接，根据测算经验数据，每条连接最多只能压满7M，理论上1个服务提供者需要20个消费者才能压满网卡。



11.为什么采用单一长连接

服务大多数服务提供者少，服务的消费者多，单一连接保证单一消费者不会压死提供者，长连接减少连接握手频率，节省资源。

12.为防止大量连接撑挂，可在服务提供方限制大接收连接数，以实现服务提供方自我保护，即设置dubbo:protocol中accept属性

13. 测试和生产公用一套zookeeper，怎么保证消费不冲突

可以通过自定义filter实现filter接口来实现dubbo接口的ip白名单，限制访问权限。

14.如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？

可以通信，启动dubbo时，消费者会从zk拉去注册的生产者的地址接口作为数据，缓存在本地，每次调用安装本地的缓存地址进行调用。

15.服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务提供者恢复。

16.注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了服务提供者列表，服务消费者可以直连提供者。

17.dubbo在安全机制方面如何解决的？

dubbo通过token令牌防止用户绕过注册中心直连，然后在注册中心管理授权，dubbo提供了黑白名单，控制服务所允许的调用方。

18.hession序列化失败hessionruntimeexception

检查服务方法传入传出参数是否实现serializable接口



19.rejectedExecutionexception异常

线程池到达最大值，在dubbo.properties中增加线程池最大值和最小值大小

 

```
20 .RpcLocalExceptionIoTargetIsNotConnected
```

检查注册中心是否开启白名单功能，如果开启了，当ip不在白名单列表中，注册中心拒绝连接。

检查端口是否正确，注册中心有2个端口，一个为控制台http端口，用于管理员查看数据，一个为程序注册服务用的tcp端口。

 

21.dubbo服务发布过程做了哪些事

暴露本地服务，暴露远程服务，启动netty，连接zookeeper，到zookeeper注册，监听zookeeper

 

22.dubbo有哪些协议，他们之间有什么特点

dubbo允许配置多协议，不同服务不同协议，大数据用短连接协议，小数据大并发用长连接协议。

 

23.什么是本地暴露和远程暴露，他们的区别

本地暴露：一个服务可能既是provider，又是consumer，自己调用自己的服务，暴露在jvm中，不需要网络通信。url是以injvm开头

远程暴露：将ip，端口等信息暴露给远程客户端，调用时需要网络通信。

dubbo处理服务暴露的关键在于Invoker转换到Exporter的过程。



**关于dubbo是用的什么协议？**

在使用dubbo的时候会配置<dubbo:protocolname="dubbo"port="20880"/>所以再回答面试官的时候就随口说的是dubbo协议，其实面试官问的此协议非彼协议，而是问的是http协议还是Tcp协议，因为dubbo的核心就是用的单一长连接进行异步通信。

​      那问题来了为什么要用dubbo进行数据传输？

​      一般服务端服务器比较少，消费端有可能会有很多项目或者工程会调用dubbo的接口，而且数据量传输较小且并发量比较高的情况下用dubbo效率会很高。

 Tcp协议就是所谓的长连接

 HTTP协议呢就是所谓的短连接，经典的三次握手。

长连接的好处：

减少来回握手的频率，当操作频繁，点对点的通讯时，可以同时发送多个数据包，以不至于服务者被消费者压死

**Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？** 

可以

1.启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。
2.注册中心对等集群，任意一台宕掉后，会自动切换到另一台 。
3.注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯 。
4.服务提供者无状态，任一台 宕机后，不影响使用 。
5.服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复 。

**2、dubbo连接注册中心和直连的区别 ？**
在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连， 点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 

服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者，注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表，注册中心和监控中心都是可选的，服务消费者可以直连服务提供者

**3、Dubbo在安全机制方面是如何解决的 ？**
Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。





# 2.Zookeeper实现服务注册与发现

zookeeper的实际运用场景：

　　场景一：统一命名服务

　　有一组[服务器](http://www.07net01.com/tags-%E6%9C%8D%E5%8A%A1%E5%99%A8-0.html)向[客户端](http://www.07net01.com/tags-%E5%AE%A2%E6%88%B7%E7%AB%AF-0.html)提供某种服务，我们希望客户端每次请求[服务端](http://www.07net01.com/tags-%E6%9C%8D%E5%8A%A1%E7%AB%AF-0.html)都可以找到服务端集群中某一台服务器，这样服务端就可以向客户端提供客户端所需的服务。对于这种场景，我们的[程序](http://www.07net01.com/tags-%E7%A8%8B%E5%BA%8F-0.html)中一定有一份这组服务器的列表，每次客户端请求时候，都是从这份列表里读取这份服务器列表。那么这份列表显然不能[存储](http://www.07net01.com/storage_networking/)在一台单节点的服务器上，否则这个节点挂掉了，整个集群都会发生故障，我们希望这份列表时高可用的。

　　高可用的[解决方案](http://www.wredian.com/tags-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-0.html)是：这份列表是分布式存储的，它是由存储这份列表的服务器共同管理的，如果存储列表里的某台服务器坏掉了，其他服务器马上可以替代坏掉的服务器，并且可以把坏掉的服务器从列表里删除掉，让故障服务器退出整个集群的运行，而这一切的操作又不会由故障的服务器来操作，而是集群里正常的服务器来完成。这是一种主动的分布式数据结构，能够在外部情况发生变化时候主动修改数据项状态的数据机构。Zookeeper框架提供了这种服务。这种服务名字就是：统一命名服务，它和[Java](http://www.07net01.com/tags-Java-0.html)EE里的JNDI服务很像。 

　　场景二：分布式锁服务

　　当分布式系统操作数据，例如：读取数据、分析数据、最后修改数据。在分布式系统里这些操作可能会分散到集群里不同的节点上，那么这时候就存在数据操作过程中一致性的问题，如果不一致，我们将会得到一个错误的运算结果，在单一进程的程序里，一致性的问题很好解决，但是到了分布式系统就比较困难，因为分布式系统里不同服务器的运算都是在独立的进程里，运算的中间结果和过程还要通过网络进行传递，那么想做到数据操作一致性要困难的多。Zookeeper提供了一个锁服务解决了这样的问题，能让我们在做分布式数据运算时候，保证数据操作的一致性。 

　　场景三：配置管理

　　在分布式系统里，我们会把一个服务应用分别部署到n台服务器上，这些服务器的[配置文件](http://www.07net01.com/tags-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-0.html)是相同的(例如：我设计的分布式网站框架里，服务端就有4台服务器，4台服务器上的程序都是一样，配置文件都是一样)，如果配置文件的配置选项发生变化，那么我们就得一个个去改这些配置文件，如果我们需要改的服务器比较少，这些操作还不是太麻烦，如果我们分布式的服务器特别多，比如某些大型[互联网](http://www.07net01.com/tags-%E4%BA%92%E8%81%94%E7%BD%91-0.html)公司的hadoop集群有数千台服务器，那么更改配置选项就是一件麻烦而且危险的事情。

　　这时候zookeeper就可以派上用场了，我们可以把zookeeper当成一个高可用的配置存储器，把这样的事情交给zookeeper进行管理，我们将集群的配置文件拷贝到zookeeper的文件系统的某个节点上，然后用zookeeper监控所有分布式系统里配置文件的状态，一旦发现有配置文件发生了变化，每台服务器都会收到zookeeper的通知，让每台服务器同步zookeeper里的配置文件，zookeeper服务也会保证同步操作原子性，确保每个服务器的配置文件都能被正确的更新。 

　　场景四：为分布式系统提供故障修复的功能

　　集群管理是很困难的，在分布式系统里加入了zookeeper服务，能让我们很容易的对集群进行管理。集群管理最麻烦的事情就是节点故障管理，zookeeper可以让集群选出一个[健康](http://www.wredian.com/tags-%E5%81%A5%E5%BA%B7-0.html)的节点作为master，master节点会知道当前集群的每台服务器的运行状况，一旦某个节点发生故障，master会把这个情况通知给集群其他服务器，从而重新分配不同节点的计算任务。Zookeeper不仅可以发现故障，也会对有故障的服务器进行甄别，看故障服务器是什么样的故障，如果该故障可以修复，zookeeper可以自动修复或者告诉系统[管理员](http://www.07net01.com/tags-%E7%AE%A1%E7%90%86%E5%91%98-0.html)错误的原因让管理员迅速定位问题，修复节点的故障。大家也许还会有个疑问，master故障了，那怎么办了？zookeeper也考虑到了这点，zookeeper内部有一个“选举领导者的算法”，master可以[动态](http://www.07net01.com/tags-%E5%8A%A8%E6%80%81-0.html)选择，当master故障时候，zookeeper能马上选出新的master对集群进行管理。

 

　　下面我要讲讲zookeeper的特点：　　

　　zookeeper是一个精简的文件系统。zookeeper这个文件系统是管理小文件的。
　　zookeeper提供了丰富的“构件”，这些构件可以实现很多协调数据结构和协议的操作。例如：分布式队列、分布式锁以及一组同级节点的“领导者选举”算法。
　　zookeeper是高可用的，它本身的[稳定性](http://www.qiche887.com/tags-%E7%A8%B3%E5%AE%9A%E6%80%A7-0.html)是相当之好，分布式集群完全可以依赖zookeeper集群的管理，利用zookeeper避免分布式系统的单点故障的问题。
　　zookeeper采用了松耦合的交互模式。这点在zookeeper提供分布式锁上表现最为明显，zookeeper可以被用作一个约会机制，让参入的进程不在了解其他进程的(或网络)的情况下能够彼此发现并进行交互，参入的各方甚至不必同时存在，只要在zookeeper留下一条消息，在该进程结束后，另外一个进程还可以读取这条信息，从而解耦了各个节点之间的关系。
　　zookeeper为集群提供了一个共享存储库，集群可以从这里集中读写共享的信息，避免了每个节点的共享操作[编程](http://www.07net01.com/)，减轻了分布式系统的开发难度。

　　zookeeper的设计采用的是观察者的设计模式，zookeeper主要是负责存储和管理大家关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应，从而实现集群中类似 Master/Slave 管理模式。

 　　由此可见zookeeper很利于分布式系统开发，它能让分布式系统更加健壮和高效。



# **ActiveMQ面试专题**

## 1. **ActiveMQ服务器宕机怎么办？**

这得从ActiveMQ的储存机制说起。在通常的情况下，非持久化消息是存储在内存中的，持久化消息是存储在文件中的，它们的最大限制在配置文件的<systemUsage>节点中配置。但是，在非持久化消息堆积到一定程度，内存告急的时候，ActiveMQ会将内存中的非持久化消息写入临时文件中，以腾出内存。虽然都保存到了文件里，但它和持久化消息的区别是，重启后持久化消息会从文件中恢复，非持久化的临时文件会直接删除。

那如果文件增大到达了配置中的最大限制的时候会发生什么？我做了以下实验：

设置2G左右的持久化文件限制，大量生产持久化消息直到文件达到最大限制，此时生产者阻塞，但消费者可正常连接并消费消息，等消息消费掉一部分，文件删除又腾出空间之后，生产者又可继续发送消息，服务自动恢复正常。

设置2G左右的临时文件限制，大量生产非持久化消息并写入临时文件，在达到最大限制时，生产者阻塞，消费者可正常连接但不能消费消息，或者原本慢速消费的消费者，消费突然停止。整个系统可连接，但是无法提供服务，就这样挂了。

具体原因不详，**解决方案：尽量不要用非持久化消息，非要用的话，将临时文件限制尽可能的调大。**

## 2. **丢消息怎么办？**

这得从java的java.net.SocketException异常说起。简单点说就是当网络发送方发送一堆数据，然后调用close关闭连接之后。这些发送的数据都在接收者的缓存里，接收者如果调用read方法仍旧能从缓存中读取这些数据，尽管对方已经关闭了连接。但是当接收者尝试发送数据时，由于此时连接已关闭，所以会发生异常，这个很好理解。不过需要注意的是，当发生SocketException后，原本缓存区中数据也作废了，此时接收者再次调用read方法去读取缓存中的数据，就会报Software caused connection abort: recv failed错误。

 

通过抓包得知，ActiveMQ会每隔10秒发送一个心跳包，这个心跳包是服务器发送给客户端的，用来判断客户端死没死。如果你看过上面第一条，就会知道非持久化消息堆积到一定程度会写到文件里，这个写的过程会阻塞所有动作，而且会持续20到30秒，并且随着内存的增大而增大。当客户端发完消息调用connection.close()时，会期待服务器对于关闭连接的回答，如果超过15秒没回答就直接调用socket层的close关闭tcp连接了。这时客户端发出的消息其实还在服务器的缓存里等待处理，不过由于服务器心跳包的设置，导致发生了java.net.SocketException异常，把缓存里的数据作废了，没处理的消息全部丢失。

 

**解决方案：用持久化消息，或者非持久化消息及时处理不要堆积，或者启动事务，启动事务后，commit()方法会负责任的等待服务器的返回，也就不会关闭连接导致消息丢失了。**

 

## 3. **持久化消息非常慢。**

 

默认的情况下，非持久化的消息是异步发送的，持久化的消息是同步发送的，遇到慢一点的硬盘，发送消息的速度是无法忍受的。但是在开启事务的情况下，消息都是异步发送的，效率会有2个数量级的提升。所以在发送持久化消息时，请务必开启事务模式。其实发送非持久化消息时也建议开启事务，因为根本不会影响性能。

 

## 4. **消息的不均匀消费。**

 

有时在发送一些消息之后，开启2个消费者去处理消息。会发现一个消费者处理了所有的消息，另一个消费者根本没收到消息。原因在于ActiveMQ的prefetch机制。当消费者去获取消息时，不会一条一条去获取，而是一次性获取一批，默认是1000条。这些预获取的消息，在还没确认消费之前，在管理控制台还是可以看见这些消息的，但是不会再分配给其他消费者，此时这些消息的状态应该算作“已分配未消费”，如果消息最后被消费，则会在服务器端被删除，如果消费者崩溃，则这些消息会被重新分配给新的消费者。但是如果消费者既不消费确认，又不崩溃，那这些消息就永远躺在消费者的缓存区里无法处理。更通常的情况是，消费这些消息非常耗时，你开了10个消费者去处理，结果发现只有一台机器吭哧吭哧处理，另外9台啥事不干。

 

**解决方案：将prefetch设为1，每次处理1条消息，处理完再去取，这样也慢不了多少。**

 

## 5. **死信队列。**

 

如果你想在消息处理失败后，不被服务器删除，还能被其他消费者处理或重试，可以关闭AUTO_ACKNOWLEDGE，将ack交由程序自己处理。那如果使用了AUTO_ACKNOWLEDGE，消息是什么时候被确认的，还有没有阻止消息确认的方法？有！

 

消费消息有2种方法，一种是调用consumer.receive()方法，该方法将阻塞直到获得并返回一条消息。这种情况下，消息返回给方法调用者之后就自动被确认了。另一种方法是采用listener回调函数，在有消息到达时，会调用listener接口的onMessage方法。在这种情况下，在onMessage方法执行完毕后，消息才会被确认，此时只要在方法中抛出异常，该消息就不会被确认。那么问题来了，如果一条消息不能被处理，会被退回服务器重新分配，如果只有一个消费者，该消息又会重新被获取，重新抛异常。就算有多个消费者，往往在一个服务器上不能处理的消息，在另外的服务器上依然不能被处理。难道就这么退回--获取--报错死循环了吗？

 

在重试6次后，ActiveMQ认为这条消息是“有毒”的，将会把消息丢到死信队列里。如果你的消息不见了，去ActiveMQ.DLQ里找找，说不定就躺在那里。

 

## 6. **ActiveMQ中的消息重发时间间隔和重发次数吗？**

ActiveMQ：是Apache出品，最流行的，能力强劲的开源消息总线。是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。JMS（Java消息服务）：是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。    

首先，我们得大概了解下，在哪些情况下，ActiveMQ服务器会将消息重发给消费者，这里为简单起见，假定采用的消息发送模式为队列（即消息发送者和消息接收者）。

①　如果消息接收者在处理完一条消息的处理过程后没有对MOM进行应答，则该消息将由MOM重发.

②　如果我们队某个队列设置了预读参数（consumer.prefetchSize），如果消息接收者在处理第一条消息时（没向MOM发送消息接收确认）就宕机了，则预读数量的所有消息都将被重发!

③　如果Session是事务的，则只要消息接收者有一条消息没有确认，或发送消息期间MOM或客户端某一方突然宕机了，则该事务范围中的所有消息MOM都将重发。

④　说到这里，大家可能会有疑问，ActiveMQ消息服务器怎么知道消费者客户端到底是消息正在处理中还没来得急对消息进行应答还是已经处理完成了没有应答或是宕机了根本没机会应答呢？其实在所有的客户端机器上，内存中都运行着一套客户端的ActiveMQ环境，该环境负责缓存发来的消息，负责维持着和ActiveMQ服务器的消息通讯，负责失效转移（fail-over）等，所有的判断和处理都是由这套客户端环境来完成的。

我们可以来对ActiveMQ的重发策略（Redelivery Policy）来进行自定义配置，其中的配置参数主要有以下几个：

可用的属性

 属性 默认值 说明

l  collisionAvoidanceFactor  默认值0.15 ,  设置防止冲突范围的正负百分比，只有启用useCollisionAvoidance参数时才生效。

l  maximumRedeliveries  默认值6 ,  最大重传次数，达到最大重连次数后抛出异常。为-1时不限制次数，为0时表示不进行重传。

l  maximumRedeliveryDelay  默认值-1,  最大传送延迟，只在useExponentialBackOff为true时有效（V5.5），假设首次重连间隔为10ms，倍数为2，那么第二次重连时间间隔为 20ms，第三次重连时间间隔为40ms，当重连时间间隔大的最大重连时间间隔时，以后每次重连时间间隔都为最大重连时间间隔。

l  initialRedeliveryDelay  默认值1000L,  初始重发延迟时间

l  redeliveryDelay  默认值1000L,  重发延迟时间，当initialRedeliveryDelay=0时生效（v5.4）

l  useCollisionAvoidance  默认值false,  启用防止冲突功能，因为消息接收时是可以使用多线程并发处理的，应该是为了重发的安全性，避开所有并发线程都在同一个时间点进行消息接收处理。所有线程在同一个时间点处理时会发生什么问题呢？应该没有问题，只是为了平衡broker处理性能，不会有时很忙，有时很空闲。

l  useExponentialBackOff  默认值false,  启用指数倍数递增的方式增加延迟时间。

l  backOffMultiplier  默认值5,  重连时间间隔递增倍数，只有值大于1和启用useExponentialBackOff参数时才生效。

　